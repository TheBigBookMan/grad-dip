## Introduction
- **Define AI**- making machines seem like they are acting like humans
- **History AI**- past half century
	- 1956 coined AI, see if it could develop like a child with problem solving etc
- **Driving development**-
	- 90% of worlds data generated in past 2 years
	- computers can now make sense of it
- **Different areas**- 
	- Robots are the shell of the AI going on under the hood
	- ML machines become better overtime from learning from experience
- **Recent successes**
	- facial recognition
	- text recognition
	- self-driving vehicles
- **AI Branches**-
	- **Game Playing**- define strateigies to play specific games like chess, based on previously made experiences from games
	- **Automated Resoning**- conduct logic reasoning (propositiona llogic, first order login, high order logic, abductive logic) by using a computer
		- problems that require logical steps to get to the solution
		- we put the understanding of the problem in ourselves to the machine
	- **Knowledge Representation**- research on representing human knowledge in symbols to facilitate automated reasoning and storing in computers
		- formatting the data 
	- **Natural Language Processing**- analyse human language for computers to use
		- understanding, translation, analysis and summarisation of text
	- **Robotics and Planning**- robot is machine that imitates human or human activity
		- design and construction of robot (sensors, planing, decision making and mechanical moving)
	- **Machine Learning**- research and development of computer systems that are able to learn and adapt without instructions by using algorithms and statistical models to anaylyse and draw inferences from patterns in data
		- supervised learning, unsupervised learning, semi-supervised learning and reinforacement learning
	- **Semantic web and Ontology**- research on web information representation, exraction and reasoning, which enables information exchange between apps, machines and platforms

1. A(upside down)x (smart(x) <- student(x))
2. E(backwards)x student(x)
3. Ex (smart(x) ^ student(x))
4. Ax()
## Logic
- using logic to represent knowledge
- **Formal language and system**
	- **Formal language**- contains
		- set of symbols (alphabet of the language)
		- set of formation rules determining which sequences of symbols from its alphabet are well formaed formulas
		- formal language is abstract unless we assign meaning to it compared to human language where it carries meaning
	- **Formal system**- 
		- formal language with a deductive apparatus is a formal system
		- a deductive appratus consists of the axioms and rules of inference that can be used to derive theoroms
- **Truth tables**- 
- semantics (model theory) of a formal lanaguge is the study of interpretations, truth functions and models of the language
- **Proppositional logic**- can be used for problem solving, planning and decision making, as well as reasoning, it helps representing knowledge in mathematical and logical form- can be either true or false
	- **IMPORTANT**- if there is an implication, the part of the IF is false and the part of the THEN is true, then it will be FALSE, while all else will be TRUE
	- **Propositional Language**- 
		- is a formal language
		- alphabet of propositional language includes
			- propositional symbols (p, q, ...)
			- connectives (-(**negation** (opposite of whatever it is)), V(**disjunction** (logical OR between propositions)), ^(**conjuction** (logical AND between propositions)), <- (**implication** (proposition implies another (if one proposition is true then another must also be true))))
			- punctuation (( ))
	- **Well formed formula (wff)**- 
		- a proposition- a sentence that is either true or false
		- if A and B are forumlas, then (-A), (A ^ B), (A V B), (A <- B) are forumlas
		- needs to have a way to represent that it is a formula so like a conjunction or something between two formulas
- **Proposition**- a sentence that is either true or false, eg: the cat is brown- *p*
	- **Negation**- it means that it is NOT proposition (a negative of the statement), eg: the cat is not brown- *-p*
	- **Conjunction**- takes 2 logical formulas and expresses that both are true, proposition1 AND proposition2 are true, eg: the cat is brown AND the cat has fur- *p ^ q*
	- **Disjunction**- takes 2 logical formulas and expresses that atleast one is true, proposition1 OR proposition2 as long as one is true, eg: the cat is not brown OR the cat has fur- *p V q* 
	- **Implication**- takes a proposition and if it is true then the next proposition must also be true, eg: the cat is brown THEREFORE the cat has fur- *p -> q*
		- this is also true when the first proposition is FALSE, the cat is not brown SO it doesnt have fur, the cat is not brown SO it does have fur
		- logically equivalent to *-p V q* 
	- **Biconditional**- takes 2 propositions and says if proposition1 is true THEN proposition2 is true or proposition1 is false THEN proposition2 is false *p <-> q* 
- **Contrapositive**- when there's two negations in an implication they cross each other out as both ways are true of each other, eg: *(-A -> -B)* is equivalent of *(A -> B)* 
- **Axioms**- statemeents assumed to be true without proof
	- (A <- B) <- A
	- ((C <- A) <- (B <- A)) <- ((C <- B) <- A)
	- (A <- B) <- (-B <- -A)
- **Inference**- deriving logical conclustions from given premises- reach new conclusions
	- **Deductive Inference**- conclusion based on premise where premis true then conclusion must be true
		- premise1: ben is man
		- premise2: man is strong
		- conclusion: therefore ben is strong
	- **INductive Inference**- drawing general conclusion based on specific observations, not alwasy conclusion is true, but most likely
		- observation: the sun rises east everyday in recorded history
		- conclusion: therefore the sun will likely rise east tomorrow
	- **Abductive Inference**- finding the most likely explanation for observations, forms hypotheses or theories
		- observation: grass is wet in morning
		- hypotheses: probably rained last night
- **Inference Rule**- rule of inference is modus ponens rule: A and B <- A infer B. derive new propositions from existing ones
	- **Modus Ponens**- *P -> Q* if P is true, then Q must be true
- **First Order Logic**- extention of propositional logic, propositional = true/false, first order= one + variables
	- **Alphabet** of first order
		- **Variables** - (X, Y, Z...)- placeholders for objects that can be replaced by a value
		- **Constants**- (a, b, c, ...)- specific, unchanging objects in the domain, eg: *a* represents a particular object or individual
		- **Function**- (f, g, ...)- map objects to objects in the domain, they take one or more arguements and return a single object. eg: *f(x)* denotes a function that maps x to another object in the domain
			- usually returns a value or different variable
			- does not return true or false (this is what a predicate returns)
		- **Predicate**- (p, q, ...)- statements that involve variables which are neither true or false until or unless the values of the variables are specified
			- eg: *X is an animal*- there is no value for X so we cant evaluate if true or false
			- proposition has the value so we can determine if true or false
			- so once the value of the predicate has been assigned then it becomes a proposition
			- predicate returns true or false
			- **Predicate shorthand**- can break it down to make easier to read
				- *X is greater than 3* can be G(X)
				- G() is the **predicate** = *is greater than 3*
				- X is the subject/variable
				- if it's *G(5)* then this is now a proposition because we have a value of 5 so it is *5 is greater than 3* which = true
		- **Connectives**- (- (**negation**), V (**disjunction**), ^ (**conjunction**), <- (**implicaton**))
		- **Quantifiers**- (A(Upside down) (**universal quantifier**), E (backwards) (**existing quantifier**))- can combine quantifiers for more complex statements
			- specify the scope of variables within a formulas
			- **Universal Quantifier**- ∀- expresses a statement holds for all elements in the domain
				- *∀x P(x)* = *"for all x, P(x) is true* 
				- sets a general rule that applies everywhere within a domain or all memebers of a set
			- **Existential Quantifier**- ∃- states there is at least one element in the domain for which the predicate is true
				- *∃xP(x)* = "*there exists an x such that P(x) is true*"
				- express existence of at least one element that satisfies given condition, useful for stating that a particular property or relationship holds for some members of a set
		- **Punctuation** ( (  ) )
		- **Equality**- to represent equality between two terms- *x = y* = "x is equal to y"
	- **Term**- construct expressions involving predicates, functions, logical connectives- used to refer to objects in the domain
		- **Constant Term**- symbols refer to specific, fixed objects within the domain and represent particular elements not changing
			- if domain is a set of people, the constant might be Ben or Sam representing individuals specifically
		- **Variable Term**- variables placeholders representing any element in the domain, used to express generality and are bound by quantifiers in logical expressions
			- x, y, z can stand for any element in domain
		- **Function Term**- map one or more terms to anther term, term represents the result of applying a function to one or more terms
			- f(x, y) can be function(x + y) so therefore can be something like f(2, 5) where the response would be 7 as 2 + 5
	- **Atom (Atomic Formula)**- basic type of logical statement or expression, its a predicate applied to set of terms and does not contain any logical connectives
		- if p is a pedicate and X1, X1, ... Xn are terms, then p(X1, X2, ..., Xn) is an atom
		- can be used in smaller components to make a more complex statement that will have multiple atoms, eg: (P(a, b) ^ Q(c, d))
	- **Literal**- literal is an atom or the negation of an atom, *A* positive literal is an atom, *a* negative literal is the negation
		- example- if *p* is predicate, *a*, *b*, *X* are terms: then
			- p(a + b, X, Xa) is an atom
			- p(a + b, X, Xa) is also called a positive literal and -p(a + b, X, Xa) is negative literal
	- **Formation rules of first order language**- well formed formaula (wff) is:
		- an atom
		- if *A* is a formula, then (A(upside down)X)A and (E(backwards)X)A are formulas
		- if A and B are forumlas, then (-A), (A^B), (AVB), (A<-B) are forumlas
		- Example- *p* is predicate, *a*, *b*, *c*, *X* are terms: then all these are formulas
			- p(a, b, X)
			- -p(a, c, X)
			- p(a, b, X) ^ --p(a, c, X)
			- A(upside down)X((p (a, b, X) V -p(a, c, X)) <- (p (a, b, X) ^ -p (a, c, X)))
			- These are not forumlas:
			- A(upsidedown)X (p(a, b, X) p(a, c, X))
			- p(a, b, X) ^
			- they are not formulas because they have no quantifiers or predicates/functions
- **Semantics and Syntax**- 
	- **Semantics** - (model theory) of a formal language is study of interpretations, truth functions and models of the language
	- **Syntax**- (proof theory) study of deductive apparatus
	- **Semantics of first order logic**- study of interpretations, models, semantic consequeunces and semantic consistency
	- **INterpretation**- first order langageu interpretation consists of 4 parts
		- assignment of a non-empty domain D of L
		- assignment of all constants of L in D
		- assignment of all n-ary functions of L as f : Dn -> D
		- assignment of all n-ary predicates of L as p : Dn -> B
		- B is boolean set which contains 2 values TRUE and FALSE
		- interpretation is binding of specific meaning to an abstract languiage, with assignment of an interpretation to first order langageu, each formulao f the language has a truth value
		- Example:
			- p (a, b)
			- p (b, c)
			- p (X, Y) <- p (X, Z) ^ p (Z, Y)
			- can be interpretaed different ways
			- predicate *p* can be assigned as parent for a set of human individuals in which case program becomes: 
				- parent (a, b)
				- parent (b, c)
				- parent (X, Y) <- parent (X, Z) ^ parent (Z, Y)
			- *p* can also be assigned as greater _ than for the set of integets, then program becomes:
				- greater_than (a, b)
				- greater_than (b, c)
				- greater_than (X, Y) <- greater_than (X, Z) ^ greater_than (Z, Y)
	- **Definition**- I be an interprattion of the first order language and A and B be two formulas of the languge, then:
		- A is true for I iff I assigns a truth value true to A
		- -A is true for I iff I assigns a truth value false to A
		- A ^ B is true for I iff I assigns true to both A and B
		- A V B is true for I iff I assigns true to either A or B
		- B <- A is true for I iff I either A is false for I or B is true for I
		- (iff = if and only if)
	- **Model**- interpretation I is a model of a formula F (denoted as Mf) iff F is true for I. an interpretation I is a model of a set of forumlas L(upside down) (denoted as ML(upside down)) iff it is a model of each of the formulas
		- Example:
			- p (a, b)
			- p (b, c)
			- p (X, Y) <- p (X, Z) ^ p (Z, Y)
		- interpretation (parent) is not a model of the formula, the interpretation (greater_than) is a model of the formula
	- **Valid, satisfiable and unsatisfiable**- let F be a closed formula of first order langage L. F is valid in L (denoted as l=F) iff for every interpration of L the truth value of F is true; F is satisfiable if there exists and interpretation of L such that the truth of value of F under this interpretation is true; F is unsatisfiable if there is no interpretation of L under which the truth value of F is true
		- Example:
			- (A(upside down)X) (A(upside down)Y) (-p (X, Y) V p (X, Y)) is valid
			- (A(upside down)X) (A(upside down)Y) (-p (X, Y) ^ p (X, Y)) is unsatisfiable
			- (A(upside down)X) (A(upside down)Y) (p (X, Y) <- (p (X, Z) ^ p (Z, Y))) is satisfiable
		- Example:
			- if A and B are formulas then- (-A V B) <- (B <- A) and (B <- A) <- (-A V B) are valid
	- **Consequence**- formula F is a consequence of a formula G (denoted as G l=F) iff there is no such an interpretation of first order language L for which G is true and F is false. Formula F is a consequence of a set of formulas T(denoted as T l=F) iff there is no interpretation for which every formula of T is true and F is false
		- Example:
			- p (X, Y) is a consequence of q (X, Y, Z) ^ p (X, Y)
			- p (X, Y) is also a consequence of T where T = {q (X, Y, Z) ^ p (X, Y), q (X, Y, Z) V p (X, Y)}
	- **Definition**- set of formulas is consistent if it has a model
	- **Syntax of first order logic**- deductive apparats of first order logic contants seven axioms and one inference rule
	- **Axioms**- let A, B, C be formulas, the axioms of first order predicate logic are:
		- (A <- B) <- A
		- ((C <- A) <- (B <- A)) <- ((C <- B) <- A)
		- (A <- B) <- (-B <- -A)
		- A <- (A(upside down)X) A
		- (E(backwards)X)A <- A
		- ((A(upside down)X)B <- (A(upside down)X) A <- (A(upsidedown)X) (B <-A)
		- if A is an axionm then (A(upsidedown)X) A is also axionm
		- inference rule of first order logic is the Modus ponens rule
	- **Modus ponens rule**- if A and B are formulas then B is the immediate consequence of A and B <- A
	- **Proof**- proof is a finite sequence of formulas in which each formula is either and axiom or an immediate consequence of the previous formulas by modus ponens rule
	- **Theorem**- formula F is a theorem of first order logic if there is a proof in which the last forumla is F then it is denoted as l - F
		- Example:
			- if A, B, C are formulas the sequence below is a proof
			- if A is a formula the sequence below is not a proof
			- if A, B, C are formulas the sequence below is a proof
			- (A <- B) <- A (Axiom (1))
			- ((C <- A) <- (B <- A)) <- ((C <- B) <- A) (Axiom (2))
			- ((A <- A) <- (B <- A)) <- ((A <- B) <- A) Axiom(2)
			- ((A <- A) <- (B <- A)) (Modus Ponens rules)
		- Example: if A is a formula the sequence below is not a proof
			- A
			- (A <- B) <- A (Axiom (1))
			- A <- B (Modus Ponens rule)
		- Example: some theorems of first order logic are listed below, if X is a variable and p and q are predicate symbols then:
			- -(A(upside down)X) p(X) <-> (E(backwards)X) -p(X)
			- -(E(backwards)X) p(X) <-> (A(upside down)X) -p(X)
			- -(p(X) ^ q(X)) <-> (-p(X) V -q(X))
			- -(p(X) V q(X)) <-> (-p(X) ^ -q(X))
			- --p(X) <-> p(X)
			- (p(X) <- q(X)) <-> (-p (X) V q(X))
			- symbol <-> defined as follows: for any formulas A and B, A <-> B is equivalent to ((A <- B) ^ (B <- A))
	- **Derivation**- F be a formula and T be a set of formulas. Derivation of F from T is a finite sequence of formulas satisfying the following conditions: 
		- F is the last formula of the sequence
		- each of the formula is an axiom or a immediate conseuqnce of he previous frmulas or a formula of T
		- in a special case when T is empty, a derivation becomes a proof
		- Example:
			- T = {A, B, C <- A ^ B} the sequence below is a derivation of C from T
			- A (formula from T)
			- B (formula from T)
			- C <- A ^ B (formula from T)
			- C (Modus Ponens rule)
	- **Definitions**- F be a formula and T be a set of formulas. F is defined as a consequence (logical consequence) of T if there is a dervation of F from T denoted as T l - F
		- Example: in previous example where T = {A, B, C <- A ^ B} C is a consequence of T
	- **Consistent**- set of T of formulas is deinfed as consistent if and only if there is not such formula F that T l - F and T l - -F
		- Example:
			- T = {A, B, -C <- A, C <- A ^ B} is a set which is inconsistent because both C and -C can be derived from T
	- **Theorem**- formula is consequence of a set of formulas (in syntax) if and only if it is a consequence of the set (in semantics). a set of formulas are consistent (in syntax) if and only if they are consistent (in semantics)

## Knowledge Representation
- research field of AI understanding, designing, implementing ways of representing information in computers so computer can use the information
	1. to derive information that is implied by it
	2. to converse with people in natural languages
	3. to decide waht to do next
	4. to solve problems in areas that normally require human expertise
- **Types knowledge representation mechanisms**
	- **Scripts**- structure that prescribes set of circumstances which could be expected to follow on from one another, chain of situations which could be anticipated. 
		- used in natural language understanding systems to organise a knowledge base in terms of the situations that the system is to understand
		- Beneficial because:
			1. events tend to occur in known runs or patterns
			2. causal relationships between events exist
			3. entry conditions exist which allow an event to take place
			4. prerequisites exist upon events taking place like when a student progresses through a degree scheme, or when a purchaser buys a house
		- usually represented using conceptual dependency structures
		- **Components of a script**-
			- **Entry Conditions**- these must be satisfied before events in the script can occur 
				- customer is hungry, bustomer has money, restuarant is open
			- **Results**- conditions that will be true after events in script occur
				- customer not hungry, customer has less money, owner has more money
			- **Objects**- factors/items that support the content of the script- the objects involved in the events
				- tables, menu, food, money
			- **Roles**- individual participants in the script and the actions they perform
				- customer, waiter, cook, cashier, owner
			- **Scenes**- the script is broken up into a sequence of scenes, each of which presents a temporal aspect of the script
				- Scene 1: customer enters restaurent, customer looks at tables, customer decies where to sit
				- Scene 2: waiter brings menyu, customer orders food
	- **Frames**- 
		- frames are collection of attributes or slots and associated values that describe a real world entity
		- each frame represents a class, or an instance of real world entity
		- frames are extensions of record datatypes in databases
		- similar to a relational database how tables are conencted through inheritance
			- an orange class is a child of the fruit class inheriting certain characteristics
			- also how a frame may have a slot which is another frame
				- a UniClass(startTime, startDate, Lecturer (other frame with name, specialty))
	- **Semantic Networks**- represents knowledge as a graph
		- graph based knowledge representations
		- use of nodes that may represent an entity with an arc that links an entity to another entity (Ben (entity) -> likes (arc) apples (entity))
		- can also link entities together through inheritance and show how entities are conneted
		- **Quillians Network**- represent the meaning of english words by traversing a network of related words to reach the final understanding of the word
			- each node is a word concept and a word is defined in terms of other words and the components of the definition are defined in the same fashion
			- looking uop the meaning of a wod we raverse this network until we are satisfied that we understand the original word
			- prgram used to find relationships between pairs of english words
			- find links between words through nodes and leafs of words that are similar
			- problem with this was it had to deal with complexities of many domains
		- estimate the distance between words (identifying synonyms)- used for information retrieval
			- like a question-answering system can estimate the distance between a question entered and multiple answers found on interenet, then estimate distance between the question and each answer and then display answer shotest distnace
			- measure the distance by using Quillians by seeing the nodes and leafs etc between question to answer

## Automated Reasoning
- Logix is study of correct reasoning and is the science of proof, thinking and inference
- **Inference Technique**- 
	- derive logical conclusion given rules and facts
	- enables AI to simluate human-like decision making and problem solving capabilities
- **Inference Engine**- component of intelligent system in AI which applies logical rules to the knowledge base to infer new information from known facts
	- first inference engine was part of the expert system
	- inference engine commonly proceeds in two modes
		- **Forward Chaining**- 
			- data-driven, automatic decision making, unconscious processing
			- eg object recognition, routine decisions, expert system- design to replace an expert in the domain (e.g. determining if product is good or not when made, also taking in medical symptoms and determining a diagnosis)
			- may do lots of work that is irrelevant to the goal
			- considers all possible outcomes
			- its like it adds on more stuff from the start to reach a goal through logic
			- **Forward Chaining Process**-
				1. **Start with Facts**- our knowledge
					- stored in a knowledge base
					- e.g. cloudy, raining
				2. **Apply Rules to Facts**- 
					- apply some sort of logic (rule) to the facts which then infers a new fact
					- e.g. cloudy matches rule 1 (might_rain <- cloudy), infers new fact: might_rain
						- raining matches rule 2 (carry_umbrella <- raining), infers new fact: carry_umbrella
				3. **Update KNowledge Base**- 
					- after infering new facts, update knowledge base with new facts
					- e.g. cloudy, raining, might_rain, carry_umbrella
				4. **Repeat Until No New Facts Can Be Inferred**- 
					- until all rules can not infer any more facts then stop
				- **Conclusion**- the system has inferred tha tthe person should carry an umbrella based on the facts 'it is cloudy' and 'its raining' and the rules that link these conditions to the action of carrying the umbrella
			1. Start with given proposition symbols (atomic sentence) eg A, B
			2. Iteratively try to infer truth of additional proposition symbols (A ^ B O=> C) therefore we establish C is true
			3. Continue until 
				1. no more inference can be carried out
				2. goal is reached
		- **Backward Chaining**- Work backwards from the query Q
			- goal-driven, appropriate for problem solving
			- tests a specific hypothesis or goal
			- e.g. where are my keys? How do i get into phd program?
			- complexity can be much less than linear in size of KB
			- this is where you kind of backtrack with logic from the end goal to the start
			- **Backward Chaining Process**- backtraqcking from goal through the rules and facts
				1. **Start with Goal**- this is true
					- goal is carry_umbrella and prove this goal is true
				2. **MAtch the goal with a rule**- 
					- look for the rule that leads to the goal carru_umbrella
					- rule 2: carry_umbrella <- raining
					- carry_umbrella is conclusion rule 2
					- subgoal, prove condition of rule 2: raining (is true)
				3. **Match subgoal with fact**-
					- check facts to see if fact is true or not (this will determine the end goal)
					- carry_umbrella <- raining (raining is true)
				4. **Subgoal Satsified**- 
					- since subgoal raining is satisfied by the fact (facts are true), original goal carry_umbrella is also satisfied
				- **Conclusion**- carry_umbrella is true based on the facts and rules
			1. To prove Q by BC
			2. check if Q is known already OR
			3. prove BC all premises of some rule concluding q
			4. Avoid loops: check if new subgoal is already on the goal stack
			5. Avoid repeated work; check if new subgoal-
				1. has already been proved true
				2. has already failed
- **SLD-resolution (Selective Linear Definite Clause Resolution)**- SLD-resolution defines process prove a goal for a logic progmra. SLD-resolution contains a set of SLD-derivations for inference and a set of rules (computation rule, selection rule, and ordering rule)
	- **Three Rules**-
		- **Computational Rule**- function from a set of definite goals to  a set of atoms that the value of the function for a goal is an atom, called the selected atom, in that goal
		- **Search Rule**- strategy of searching for SLD-trees to find success branches
		- **Ordering Rule**- specifies the order in which program clauses are to be tried in the derivation. Computation, search and ordering rules aplpied in SLD-resoltuom are
			- a. select subgoals according to their order (left to right)
			- b. depth-first search
			- c. respect order of the clauses in program
	- **Soundess and Completeness**- in logic program P, 'the goal G can be derived by SLD-resolution' means that SLD-derivation with the goal G on the program P is successful. 'The goal G cannot be derived by the SLD-resolution' means the derivation with G on P is failed
		- **Sound**- resolution is sound if the derived is a consequence of the program
		- **COmplete**- resolution is complete if all consequences of the program can be derived by resoliution
		- **Theorem**- SLD-resolution is sound, SLD-resolution is complete if the derivation is finite
	- clasues include facts and rules
	- backward chaning method in PROLOG for deriving logical conclusions from a set of definite clauses
	- key concepts include resolution, unification, subsitutation, derivation and SLD tree
	- **Intial Resoltion**- 
		1. leads to unifying the goal with head of the clause.
			- **Variabvles**- capital case, value can change
			- **Constnat**- lower case, cant change
			- look at the head of the clause to resolve the head with a specific rule
			- **Clauses**- are either facts or rules
			- **Unification**- matching the goal with a rule (clauses)
				- basically identifying where the goal matches with the current rule (should be same named ege parent(ben, justin) with parent(X,Y))
				- if unification in FACT then use it, if not then in clause to then find the fact that works in the clause
				- if no unification, then will return that the logic has ended without any success
				- if successful then it produces a substitution that can be applied to both goal and rule
				- **Unifier**  write it out like- X/ben, Y/justin
			- **Substitution**- replace the variables in the clause with terms (constants, varialbes or functions)
				- allows generalisig of rusles and goals by making them compatible for unification
				- basically when you have identified the header with the rule like above then you just substitute the variables with the terms (ben, justin with X, Y = {X = ben, Y = justin})
			- **Derivation**- sequence of resolution steps to derive new goal or conclusion from initial goal
				- applies role to goal through unification and substitution
				- generates new subgoals that must be resolved
				- can then look at the rule with the new terms replacing the variables: parent(X, Y) :- father(X, Y) becomes parent(ben, justing) :- father(X, Y)
				- new goal is father(ben, justin)
				- this is based on unifying the variables with terms and then substituing them in the logic process rules to identify the goal
			- **Tree (SLD Tree)**-
				- A tree structure that represents derivation process of a goal using SLD resolution
				- root is initial goal
				- each node represents a goal or subgoal
				- edges represent application of rules (via resolution)
				- branches represent different possible derivations (alternative rule applications)
					- branches can be when there is no direct unification for a clause
					- branch will then continue if there is conjunction for each goal then continue that branch
					- branch goes depth first when finding solution
					- branches can be different clauses, so if no facts and then few clauses that could work, you must try all in order
				- successful derivation is at a leaf where all goals are resolved
				- **Root**- the initiall query goal
					- e.g parent(ben, justin)
				- **Subgoal Node**- generated by applying the rule 
					- e.g father(ben, justin)
				- **Resolution**- if completion
					- e.g. Success
				- **Fact**- can be displayed by <- 
					- are undeniably true (hence why first chosen in a clause)
					- e.g. son(ben, justin)<-
				- **Rule**- can be displyaed by a clause with <- in middle
					- e.g. parent(X, Y) <- son(Y, X) 


## PROLOG
- PROgramming in LOGic
- facilitates-
	- propositional logic
	- first order reasonging
	- higher order reasoning
- predicates can be defined such as:
	- daughter(X, Y)- X is a daughter of Y
	- son(X, Y)- X is a son of Y etc
	- male(X)- X is a male
- logic program in PROLOG written like
	- daughter(samantha, rebecca)- samantha is daughter of rebecca
	- son(jack, michael)- jack is son of michael
	- male(jack)- jack is a male
- **Rule**- 
	- !!!! THESE ARE ORDER FROM RIGHT TO LEFT
	- parent(X, Y) :- daughter(Y, X): if Y is daughter of X then X is parent of Y
	- mother(X, Y) :- paret(X,Y), not(male(X)): if X is parent of Y AND not male then X is mother of Y
	- father(X, Y) :- parent(X, Y), male(X): if X is parent of Y AND male THEN X is father of Y
- Data types not defined, numerical caluclations supportes
- **Constants**- 
	- value that can never be changed
	- value of integer, decimal, sequence of symbols, string, list, structure
	- may/may not have identifier
		- identifier of a constant may contain letters, digits, underscores 
		- start lower case letter
- **Variables**- 
	- value that can vary
	- always has an identifier
		- identifier contains letters, digits, underscores 
		- starts with capital letter or underscore
- **Terms**-
	- term is either a variable or constant
- **Predicates**-
	- function with only two possible values- true/false
	- may be unary (takes only one parameter) or multiary (takes more than one parameter)
		- if takes no parameters then its a proposition?
	- identifier may contain letters, digists, underscores
		- starts with lower case letter
	- can write like "greater_than/2" to show greater than function and /2 represents takes 2 parmaters
- **Atom**-
	- if *p* (predicate) n-ary (n parameters) and *t* (term) 
	- *p(t1, ... tn)* is an atom
	- example: greater_than/2(1, 5) - this will see if 1 is greater than 5
-  **Logical Connectives**-
	- conjunction (AND) - ,
	- disjunction (NOT)- ;
	- implication (then)- :-
	- negation (not): not
	- e.g: parent(X, Y) :- daughter(Y, X) same as parent(X, Y) <- daughter(Y, X)- if Y is daughter of X then X is parent of Y
- **Logic Program**- logic program is a set of program clauses
	- **Program Clause**-  set of program clauses, can be fact, rule or goal
		- **Fact**- represents a statement which is true
			- PROLOG- *p(a1, a2.... an)* where p is predicate and a1,a2 etc are terms (its an Atom)
			- e.g. daughter(samantha, rebecca) etc
		- **Rule**- indicates a relation of implication (if, then etc)
			- PROLOG- B :- A1, A2,... An where B is an atom and A1, A2 etc are atoms or negation of atoms
			- B is the **head(consequent)** of the rule and A1, A2, Ak is the **body(premise)** of the rule
			- e.g. parent(X, Y) :- daughter(Y, X).
			- parent(X, Y) = head, daughter(Y, X) = body, :- = implication, . = always need full stop at end to end the rule
		- **Goal**- an atom or conjunction of multiple atoms
			- e.g. ?mother(rebecca, jack) is a goal
			- e.g. ?parent(X, samanatha), mother(Rebecca, Jack)  is conjunction
- **Arithmetic Calculations**- PROLOG has simple maths
	- **Arithmetic Operators**-
		- +, -, *, /, mod
		- instead of "=" it's "is" 
		- >, <, <=, =<
		- =:= comparison of numerical values, can be an expression and values
		- = general comparison- compares values on left and right sides, if one hasnt been boung then the value on other side will be bound (unification)
		- == strict comparison, values on sides must be the same, no value binding will be conducted, no expresison must be values
		- the slashes go opposite way (they are invisible in obsidian)
		- "=/=" not equal
		- "/=" not equal
		- "/= =" string
		- ?maximum_num(4, 5, X)- largest number of 4 or 5 will return into value X
			- can also do it like ?maxiumum_num(X, 4, 5)- largest nunmber of 4 or 5 returns X?
		- predicate f(N, F) where the N is parameter and F is bined (returned) value
- **Input**- built-in predicate read/1 is defined fo reaching from standard input (or file)
	- *read(x)* 
	- reads a term from the standard input or a file, and uses the input value to instantiate X, the input is treminated by full stop
- **Output**- predicate write/1 is defined for output
	- *write(X)* 
	- outputs the contents of X
	- e.g test1 :- read(X), Y = X, Write(Y). this will take input of a number, check if that number is same as Y and (if Y has no value it binds it to that value) and then it ouputs whatever Y is (could be X as it wasnt bound, or a number previously)
	- built in predicate tab/1 outputs tab spaces 
	- built in preitate nl/0 outputs a new line
		- e.g. test1 :- read(X), Y == X, nl, tabl(12), write(Y). this takes input as X then checks strict checking on Y to X, then creates a new line and indents tab by 12 and writes out Y (no value binding conducted)
	- abstract :- nl, write('enter X'), read(X), positive(X). ---- a predicate can have two definitions like an if else---weird
		- positive(X) :- X < 0, Y is 0 - X, write(Y).
		- positive(X) :- X >= 0, write(X).
- **Recursion**- clause calling itself to make the problem smaller
	- goes through each recusrive then backtrack with the final clauses
- **Iteration**- loops
	- loop(Index, Index) :- body(Index)
	- loop(Index, End) :- Index < End, body(Index), Index1 is Index + 1, loop(Index1, End).
	- body(Index) :- write('in the loop with index ='), write(Index), nl.
	- same as a while loop while Index <= End: print(Index++)
	- loop normally created using two caluses, both have same head. One clause defines terminating case while other executes the body, then move the loop to next iteration
- **Selection**- if else
	- if is (then) ->
	- else is ;
	- e.g test(X) :- (X > 0 -> write('posiotive); write('negative)).
- **Lists**- 
	- sequence of elements- 
	- e.g [23, 'hey', [1, 4, 5], 45, 'string'].
	- list can be divded into two components, head and tail. first element of list is head, rest is tail of list. Head is a term, tail is a list
	- notation [ | ] used to separate the head and the tail. If list contains only one elemnt then element makes the head, tail is an empty list
		- e.g. X = [monday, tues, wed, thus]
		- weekdays([first_day | rest_days]) this then assigns first_day = monday and rest_days = [tues, wed, thurs]
	- nth1(2, [1, 2, 3, 4], X).
		- get the 2nd item of the list
		- PROLOG doesnt start with 0, starts with 0
		- X = 2
		- as getting second element (first param) binding to X
- **Structures**- PROLOG doesnt support global variables
	- scope of variable is within clause only
	- thats why variables like X, Y so common because no scope
	- dataq structures built with user-defined predicates to pass value from one clause to the other
	- data structure is an atom or composition of atoms
	- e.g. student (ben, smerd, 123232, CS50, 2024)
		- student(ben, smerd, x, y z)
		- x = 123232
		- y = CS50
		- z = 2024
	- single layer data structures, the arguements are terms, if the structures are loaded in prolog executer we can enter queries as above
	- Multi-layered structures- can nest structure in structure
		- student(names(ben, smerd), 12323, CS50, 2024)