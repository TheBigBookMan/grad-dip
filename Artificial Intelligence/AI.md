## Introduction
- **Define AI**- making machines seem like they are acting like humans
- **History AI**- past half century
	- 1956 coined AI, see if it could develop like a child with problem solving etc
- **Driving development**-
	- 90% of worlds data generated in past 2 years
	- computers can now make sense of it
- **Different areas**- 
	- Robots are the shell of the AI going on under the hood
	- ML machines become better overtime from learning from experience
- **Recent successes**
	- facial recognition
	- text recognition
	- self-driving vehicles
- **AI Branches**-
	- **Game Playing**- define strateigies to play specific games like chess, based on previously made experiences from games
	- **Automated Resoning**- conduct logic reasoning (propositiona llogic, first order login, high order logic, abductive logic) by using a computer
		- problems that require logical steps to get to the solution
		- we put the understanding of the problem in ourselves to the machine
	- **Knowledge Representation**- research on representing human knowledge in symbols to facilitate automated reasoning and storing in computers
		- formatting the data 
	- **Natural Language Processing**- analyse human language for computers to use
		- understanding, translation, analysis and summarisation of text
	- **Robotics and Planning**- robot is machine that imitates human or human activity
		- design and construction of robot (sensors, planing, decision making and mechanical moving)
	- **Machine Learning**- research and development of computer systems that are able to learn and adapt without instructions by using algorithms and statistical models to anaylyse and draw inferences from patterns in data
		- supervised learning, unsupervised learning, semi-supervised learning and reinforacement learning
	- **Semantic web and Ontology**- research on web information representation, exraction and reasoning, which enables information exchange between apps, machines and platforms
## Logic
- using logic to represent knowledge
- **Formal language and system**
	- **Formal language**- contains
		- set of symbols (alphabet of the language)
		- set of formation rules determining which sequences of symbols from its alphabet are well formaed formulas
		- formal language is abstract unless we assign meaning to it compared to human language where it carries meaning
	- **Formal system**- 
		- formal language with a deductive apparatus is a formal system
		- a deductive appratus consists of the axioms and rules of inference that can be used to derive theoroms
- **Truth tables**- 
- semantics (model theory) of a formal lanaguge is the study of interpretations, truth functions and models of the language
- **Proppositional logic**- can be used for problem solving, planning and decision making, as well as reasoning, it helps representing knowledge in mathematical and logical form- can be either true or false
	- **Propositional Language**- 
		- is a formal language
		- alphabet of propositional language includes
			- propositional symbols (p, q, ...)
			- connectives (-(**negation** (opposite of whatever it is)), V(**disjunction** (logical OR between propositions)), ^(**conjuction** (logical AND between propositions)), <- (**implication** (proposition implies another (if one proposition is true then another must also be true))))
			- punctuation (( ))
	- **Well formed formula (wff)**- 
		- a proposition- a sentence that is either true or false
		- if A and B are forumlas, then (-A), (A ^ B), (A V B), (A <- B) are forumlas
- **Proposition**- a sentence that is either true or false, eg: the cat is brown- *p*
	- **Negation**- it means that it is NOT proposition (a negative of the statement), eg: the cat is not brown- *-p*
	- **Conjunction**- takes 2 logical formulas and expresses that both are true, proposition1 AND proposition2 are true, eg: the cat is brown AND the cat has fur- *p ^ q*
	- **Disjunction**- takes 2 logical formulas and expresses that atleast one is true, proposition1 OR proposition2 as long as one is true, eg: the cat is not brown OR the cat has fur- *p V q* 
	- **Implication**- takes a proposition and if it is true then the next proposition must also be true, eg: the cat is brown THEREFORE the cat has fur- *p -> q*
		- this is also true when the first proposition is FALSE, the cat is not brown SO it doesnt have fur, the cat is not brown SO it does have fur
		- logically equivalent to *-p V q* 
	- **Biconditional**- takes 2 propositions and says if proposition1 is true THEN proposition2 is true or proposition1 is false THEN proposition2 is false *p <-> q* 
- **Contrapositive**- when there's two negations in an implication they cross each other out as both ways are true of each other, eg: *(-A -> -B)* is equivalent of *(A -> B)* 
- **Axioms**- statemeents assumed to be true without proof
	- (A <- B) <- A
	- ((C <- A) <- (B <- A)) <- ((C <- B) <- A)
	- (A <- B) <- (-B <- -A)
- **Inference**- deriving logical conclustions from given premises- reach new conclusions
	- **Deductive Inference**- conclusion based on premise where premis true then conclusion must be true
		- premise1: ben is man
		- premise2: man is strong
		- conclusion: therefore ben is strong
	- **INductive Inference**- drawing general conclusion based on specific observations, not alwasy conclusion is true, but most likely
		- observation: the sun rises east everyday in recorded history
		- conclusion: therefore the sun will likely rise east tomorrow
	- **Abductive Inference**- finding the most likely explanation for observations, forms hypotheses or theories
		- observation: grass is wet in morning
		- hypotheses: probably rained last night
- **Inference Rule**- rule of inference is modus ponens rule: A and B <- A infer B. derive new propositions from existing ones
	- **Modus Ponens**- *P -> Q* if P is true, then Q must be true
- **First Order Logic**- extention of propositional logic, propositional = true/false, first order= one + variables
	- **Alphabet** of first order
		- **Variables** - (X, Y, Z...)- placeholders for objects that can be replaced by a value
		- **Constants**- (a, b, c, ...)- specific, unchanging objects in the domain, eg: *a* represents a particular object or individual
		- **Function**- (f, g, ...)- map objects to objects in the domain, they take one or more arguements and return a single object. eg: *f(x)* denotes a function that maps x to another object in the domain
			- usually returns a value or different variable
			- does not return true or false (this is what a predicate returns)
		- **Predicate**- (p, q, ...)- statements that involve variables which are neither true or false until or unless the values of the variables are specified
			- eg: *X is an animal*- there is no value for X so we cant evaluate if true or false
			- proposition has the value so we can determine if true or false
			- so once the value of the predicate has been assigned then it becomes a proposition
			- predicate returns true or false
			- **Predicate shorthand**- can break it down to make easier to read
				- *X is greater than 3* can be G(X)
				- G() is the **predicate** = *is greater than 3*
				- X is the subject/variable
				- if it's *G(5)* then this is now a proposition because we have a value of 5 so it is *5 is greater than 3* which = true
		- **Connectives**- (- (**negation**), V (**disjunction**), ^ (**conjunction**), <- (**implicaton**))
		- **Quantifiers**- (A(Upside down) (**universal quantifier**), E (backwards) (**existing quantifier**))- can combine quantifiers for more complex statements
			- specify the scope of variables within a formulas
			- **Universal Quantifier**- ∀- expresses a statement holds for all elements in the domain
				- *∀x P(x)* = *"for all x, P(x) is true* 
				- sets a general rule that applies everywhere within a domain or all memebers of a set
			- **Existential Quantifier**- ∃- states there is at least one element in the domain for which the predicate is true
				- *∃xP(x)* = "*there exists an x such that P(x) is true*"
				- express existence of at least one element that satisfies given condition, useful for stating that a particular property or relationship holds for some members of a set
		- **Punctuation** ( (  ) )
		- **Equality**- to represent equality between two terms- *x = y* = "x is equal to y"
	- **Term**- construct expressions involving predicates, functions, logical connectives- used to refer to objects in the domain
		- **Constant Term**- symbols refer to specific, fixed objects within the domain and represent particular elements not changing
			- if domain is a set of people, the constant might be Ben or Sam representing individuals specifically
		- **Variable Term**- variables placeholders representing any element in the domain, used to express generality and are bound by quantifiers in logical expressions
			- x, y, z can stand for any element in domain
		- **Function Term**- map one or more terms to anther term, term represents the result of applying a function to one or more terms
			- f(x, y) can be function(x + y) so therefore can be something like f(2, 5) where the response would be 7 as 2 + 5
	- **Atom (Atomic Formula)**- basic type of logical statement or expression, its a predicate applied to set of terms and does not contain any logical connectives
		- if p is a pedicate and X1, X1, ... Xn are terms, then p(X1, X2, ..., Xn) is an atom
		- can be used in smaller components to make a more complex statement that will have multiple atoms, eg: (P(a, b) ^ Q(c, d))
	- **Literal**- literal is an atom or the negation of an atom, *A* positive literal is an atom, *a* negative literal is the negation
		- example- if *p* is predicate, *a*, *b*, *X* are terms: then
			- p(a + b, X, Xa) is an atom
			- p(a + b, X, Xa) is also called a positive literal and -p(a + b, X, Xa) is negative literal
	- **Formation rules of first order language**- well formed formaula (wff) is:
		- an atom
		- if *A* is a formula, then (A(upside down)X)A and (E(backwards)X)A are formulas
		- if A and B are forumlas, then (-A), (A^B), (AVB), (A<-B) are forumlas
		- Example- *p* is predicate, *a*, *b*, *c*, *X* are terms: then all these are formulas
			- p(a, b, X)
			- -p(a, c, X)
			- p(a, b, X) ^ --p(a, c, X)
			- A(upside down)X((p (a, b, X) V -p(a, c, X)) <- (p (a, b, X) ^ -p (a, c, X)))
			- These are not forumlas:
			- A(upsidedown)X (p(a, b, X) p(a, c, X))
			- p(a, b, X) ^
- **Semantics and Syntax**- 
	- **Semantics** - (model theory) of a formal language is study of interpretations, truth functions and models of the language
	- **Syntax**- (proof theory) study of deductive apparatus
	- **Semantics of first order logic**- study of interpretations, models, semantic consequeunces and semantic consistency
	- **INterpretation**- first order langageu interpretation consists of 4 parts
		- assignment of a non-empty domain D of L
		- assignment of all constants of L in D
		- assignment of all n-ary functions of L as f : Dn -> D
		- assignment of all n-ary predicates of L as p : Dn -> B
		- B is boolean set which contains 2 values TRUE and FALSE
		- interpretation is binding of specific meaning to an abstract languiage, with assignment of an interpretation to first order langageu, each formulao f the language has a truth value
		- Example:
			- p (a, b)
			- p (b, c)
			- p (X, Y) <- p (X, Z) ^ p (Z, Y)
			- can be interpretaed different ways
			- predicate *p* can be assigned as parent for a set of human individuals in which case program becomes: 
				- parent (a, b)
				- parent (b, c)
				- parent (X, Y) <- parent (X, Z) ^ parent (Z, Y)
			- *p* can also be assigned as greater _ than for the set of integets, then program becomes:
				- greater_than (a, b)
				- greater_than (b, c)
				- greater_than (X, Y) <- greater_than (X, Z) ^ greater_than (Z, Y)
	- **Definition**- I be an interprattion of the first order language and A and B be two formulas of the languge, then:
		- A is true for I iff I assigns a truth value true to A
		- -A is true for I iff I assigns a truth value false to A
		- A ^ B is true for I iff I assigns true to both A and B
		- A V B is true for I iff I assigns true to either A or B
		- B <- A is true for I iff I either A is false for I or B is true for I
		- (iff = if and only if)
	- **Model**- interpretation I is a model of a formula F (denoted as Mf) iff F is true for I. an interpretation I is a model of a set of forumlas L(upside down) (denoted as ML(upside down)) iff it is a model of each of the formulas
		- Example:
			- p (a, b)
			- p (b, c)
			- p (X, Y) <- p (X, Z) ^ p (Z, Y)
		- interpretation (parent) is not a model of the formula, the interpretation (greater_than) is a model of the formula
	- **Valid, satisfiable and unsatisfiable**- let F be a closed formula of first order langage L. F is valid in L (denoted as l=F) iff for every interpration of L the truth value of F is true; F is satisfiable if there exists and interpretation of L such that the truth of value of F under this interpretation is true; F is unsatisfiable if there is no interpretation of L under which the truth value of F is true
		- Example:
			- (A(upside down)X) (A(upside down)Y) (-p (X, Y) V p (X, Y)) is valid
			- (A(upside down)X) (A(upside down)Y) (-p (X, Y) ^ p (X, Y)) is unsatisfiable
			- (A(upside down)X) (A(upside down)Y) (p (X, Y) <- (p (X, Z) ^ p (Z, Y))) is satisfiable
		- Example:
			- if A and B are formulas then- (-A V B) <- (B <- A) and (B <- A) <- (-A V B) are valid
	- **Consequence**- formula F is a consequence of a formula G (denoted as G l=F) iff there is no such an interpretation of first order language L for which G is true and F is false. Formula F is a consequence of a set of formulas T(denoted as T l=F) iff there is no interpretation for which every formula of T is true and F is false
		- Example:
			- p (X, Y) is a consequence of q (X, Y, Z) ^ p (X, Y)
			- p (X, Y) is also a consequence of T where T = {q (X, Y, Z) ^ p (X, Y), q (X, Y, Z) V p (X, Y)}
	- **Definition**- set of formulas is consistent if it has a model
	- **Syntax of first order logic**- deductive apparats of first order logic contants seven axioms and one inference rule
	- **Axioms**- let A, B, C be formulas, the axioms of first order predicate logic are:
		- (A <- B) <- A
		- ((C <- A) <- (B <- A)) <- ((C <- B) <- A)
		- (A <- B) <- (-B <- -A)
		- A <- (A(upside down)X) A
		- (E(backwards)X)A <- A
		- ((A(upside down)X)B <- (A(upside down)X) A <- (A(upsidedown)X) (B <-A)
		- if A is an axionm then (A(upsidedown)X) A is also axionm
		- inference rule of first order logic is the Modus ponens rule
	- **Modus ponens rule**- if A and B are formulas then B is the immediate consequence of A and B <- A
	- **Proof**- proof is a finite sequence of formulas in which each formula is either and axiom or an immediate consequence of the previous formulas by modus ponens rule
	- **Theorem**- formula F is a theorem of first order logic if there is a proof in which the last forumla is F then it is denoted as l - F
		- Example:
			- if A, B, C are formulas the sequence below is a proof
			- if A is a formula the sequence below is not a proof
			- if A, B, C are formulas the sequence below is a proof
			- (A <- B) <- A (Axiom (1))
			- ((C <- A) <- (B <- A)) <- ((C <- B) <- A) (Axiom (2))
			- ((A <- A) <- (B <- A)) <- ((A <- B) <- A) Axiom(2)
			- ((A <- A) <- (B <- A)) (Modus Ponens rules)
		- Example: if A is a formula the sequence below is not a proof
			- A
			- (A <- B) <- A (Axiom (1))
			- A <- B (Modus Ponens rule)
		- Example: some theorems of first order logic are listed below, if X is a variable and p and q are predicate symbols then:
			- -(A(upside down)X) p(X) <-> (E(backwards)X) -p(X)
			- -(E(backwards)X) p(X) <-> (A(upside down)X) -p(X)
			- -(p(X) ^ q(X)) <-> (-p(X) V -q(X))
			- -(p(X) V q(X)) <-> (-p(X) ^ -q(X))
			- --p(X) <-> p(X)
			- (p(X) <- q(X)) <-> (-p (X) V q(X))
			- symbol <-> defined as follows: for any formulas A and B, A <-> B is equivalent to ((A <- B) ^ (B <- A))
	- **Derivation**- F be a formula and T be a set of formulas. Derivation of F from T is a finite sequence of formulas satisfying the following conditions: 
		- F is the last formula of the sequence
		- each of the formula is an axiom or a immediate conseuqnce of he previous frmulas or a formula of T
		- in a special case when T is empty, a derivation becomes a proof
		- Example:
			- T = {A, B, C <- A ^ B} the sequence below is a derivation of C from T
			- A (formula from T)
			- B (formula from T)
			- C <- A ^ B (formula from T)
			- C (Modus Ponens rule)
	- **Definitions**- F be a formula and T be a set of formulas. F is defined as a consequence (logical consequence) of T if there is a dervation of F from T denoted as T l - F
		- Example: in previous example where T = {A, B, C <- A ^ B} C is a consequence of T
	- **Consistent**- set of T of formulas is deinfed as consistent if and only if there is not such formula F that T l - F and T l - -F
		- Example:
			- T = {A, B, -C <- A, C <- A ^ B} is a set which is inconsistent because both C and -C can be derived from T
	- **Theorem**- formula is consequence of a set of formulas (in syntax) if and only if it is a consequence of the set (in semantics). a set of formulas are consistent (in syntax) if and only if they are consistent (in semantics)

## Knowledge Representation
- research field of AI understanding, designing, implementing ways of representing information in computers so computer can use the information
	1. to derive information that is implied by it
	2. to converse with people in natural languages
	3. to decide waht to do next
	4. to solve problems in areas that normally require human expertise
- **Types knowledge representation mechanisms**
	- **Scripts**- structure that prescribes set of circumstances which could be expected to follow on from one another, chain of situations which could be anticipated. 
		- used in natural language understanding systems to organise a knowledge base in terms of the situations that the system is to understand
		- Beneficial because:
			1. events tend to occur in known runs or patterns
			2. causal relationships between events exist
			3. entry conditions exist which allow an event to take place
			4. prerequisites exist upon events taking place like when a student progresses through a degree scheme, or when a purchaser buys a house
		- usually represented using conceptual dependency structures
		- **Components of a script**-
			- **Entry Conditions**- these must be satisfied before events in the script can occur 
				- customer is hungry, bustomer has money, restuarant is open
			- **Results**- conditions that will be true after events in script occur
				- customer not hungry, customer has less money, owner has more money
			- **Objects**- factors/items that support the content of the script- the objects involved in the events
				- tables, menu, food, money
			- **Roles**- individual participants in the script and the actions they perform
				- customer, waiter, cook, cashier, owner
			- **Scenes**- the script is broken up into a sequence of scenes, each of which presents a temporal aspect of the script
				- Scene 1: customer enters restaurent, customer looks at tables, customer decies where to sit
				- Scene 2: waiter brings menyu, customer orders food
	- **Frames**- 
		- frames are collection of attributes or slots and associated values that describe a real world entity
		- each frame represents a class, or an instance of real world entity
		- frames are extensions of record datatypes in databases
		- similar to a relational database how tables are conencted through inheritance
			- an orange class is a child of the fruit class inheriting certain characteristics
			- also how a frame may have a slot which is another frame
				- a UniClass(startTime, startDate, Lecturer (other frame with name, specialty))
	- **Semantic Networks**- represents knowledge as a graph
		- graph based knowledge representations
		- use of nodes that may represent an entity with an arc that links an entity to another entity (Ben (entity) -> likes (arc) apples (entity))
		- can also link entities together through inheritance and show how entities are conneted
		- **Quillians Network**- represent the meaning of english words by traversing a network of related words to reach the final understanding of the word
			- each node is a word concept and a word is defined in terms of other words and the components of the definition are defined in the same fashion
			- looking uop the meaning of a wod we raverse this network until we are satisfied that we understand the original word
			- prgram used to find relationships between pairs of english words
			- find links between words through nodes and leafs of words that are similar
			- problem with this was it had to deal with complexities of many domains
		- estimate the distance between words (identifying synonyms)- used for information retrieval
			- like a question-answering system can estimate the distance between a question entered and multiple answers found on interenet, then estimate distance between the question and each answer and then display answer shotest distnace
			- measure the distance by using Quillians by seeing the nodes and leafs etc between question to answer